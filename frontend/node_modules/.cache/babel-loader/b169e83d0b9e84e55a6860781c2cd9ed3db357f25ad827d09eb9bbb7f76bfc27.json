{"ast":null,"code":"import { fetchProductsBatch } from \"../../services/ProductService\";\nexport async function fetchNewProducts({\n  setProducts,\n  currentPage,\n  setHasEndingPosts\n}) {\n  const newProducts = await fetchProductsBatch(currentPage, 3);\n  setProducts(oldProducts => [...oldProducts, ...newProducts]);\n  if (newProducts.length < 3) {\n    setHasEndingPosts(true);\n  }\n}\nconst loadMoreProducts = async () => {\n  await new Promise(resolve => setTimeout(resolve, 1200));\n  if (loading || hasEndingPosts) return;\n  setLoading(true);\n  await fetchNewProducts({\n    setProducts,\n    currentPage,\n    setHasEndingPosts\n  });\n  setLoading(false);\n};\nexport function newObserver({\n  loading,\n  hasEndingPosts,\n  setCurrentPage\n}) {\n  const options = {\n    root: null,\n    rootMargin: \"20px\",\n    threshold: 1.0\n  };\n  const observer = new IntersectionObserver(entries => {\n    const target = entries[0];\n    if (target.isIntersecting && !loading && !hasEndingPosts) {\n      setCurrentPage(oldPage => oldPage + 1);\n    }\n  }, options);\n  return observer;\n}","map":{"version":3,"names":["fetchProductsBatch","fetchNewProducts","setProducts","currentPage","setHasEndingPosts","newProducts","oldProducts","length","loadMoreProducts","Promise","resolve","setTimeout","loading","hasEndingPosts","setLoading","newObserver","setCurrentPage","options","root","rootMargin","threshold","observer","IntersectionObserver","entries","target","isIntersecting","oldPage"],"sources":["/home/gabriel/Desktop/projetos2024/nilo/frontend/src/component/ProductList/productListUtils.js"],"sourcesContent":["\nimport { fetchProductsBatch } from \"../../services/ProductService\";\n\nexport async function fetchNewProducts ({setProducts,currentPage,setHasEndingPosts}){\n    const newProducts = await fetchProductsBatch(currentPage, 3);\n    setProducts((oldProducts) => [...oldProducts, ...newProducts]); \n    if(newProducts.length <3){\n        setHasEndingPosts(true)\n    }\n}\n\nconst loadMoreProducts = async () => {\n    await new Promise(resolve => setTimeout(resolve, 1200)); \n    if (loading || hasEndingPosts) return; \n\n    setLoading(true);\n    await fetchNewProducts({setProducts,currentPage, setHasEndingPosts})\n    setLoading(false);\n  };\n\nexport function newObserver({loading, hasEndingPosts, setCurrentPage}){\n    const options = {\n        root: null,\n        rootMargin: \"20px\",\n        threshold: 1.0,\n      };\n\n    const observer = new IntersectionObserver((entries) => {\n        const target = entries[0];\n        if (target.isIntersecting && !loading && !hasEndingPosts) {\n          setCurrentPage((oldPage) => oldPage + 1);\n        }\n      }, options);\n    \n    return observer;\n}"],"mappings":"AACA,SAASA,kBAAkB,QAAQ,+BAA+B;AAElE,OAAO,eAAeC,gBAAgBA,CAAE;EAACC,WAAW;EAACC,WAAW;EAACC;AAAiB,CAAC,EAAC;EAChF,MAAMC,WAAW,GAAG,MAAML,kBAAkB,CAACG,WAAW,EAAE,CAAC,CAAC;EAC5DD,WAAW,CAAEI,WAAW,IAAK,CAAC,GAAGA,WAAW,EAAE,GAAGD,WAAW,CAAC,CAAC;EAC9D,IAAGA,WAAW,CAACE,MAAM,GAAE,CAAC,EAAC;IACrBH,iBAAiB,CAAC,IAAI,CAAC;EAC3B;AACJ;AAEA,MAAMI,gBAAgB,GAAG,MAAAA,CAAA,KAAY;EACjC,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;EACvD,IAAIE,OAAO,IAAIC,cAAc,EAAE;EAE/BC,UAAU,CAAC,IAAI,CAAC;EAChB,MAAMb,gBAAgB,CAAC;IAACC,WAAW;IAACC,WAAW;IAAEC;EAAiB,CAAC,CAAC;EACpEU,UAAU,CAAC,KAAK,CAAC;AACnB,CAAC;AAEH,OAAO,SAASC,WAAWA,CAAC;EAACH,OAAO;EAAEC,cAAc;EAAEG;AAAc,CAAC,EAAC;EAClE,MAAMC,OAAO,GAAG;IACZC,IAAI,EAAE,IAAI;IACVC,UAAU,EAAE,MAAM;IAClBC,SAAS,EAAE;EACb,CAAC;EAEH,MAAMC,QAAQ,GAAG,IAAIC,oBAAoB,CAAEC,OAAO,IAAK;IACnD,MAAMC,MAAM,GAAGD,OAAO,CAAC,CAAC,CAAC;IACzB,IAAIC,MAAM,CAACC,cAAc,IAAI,CAACb,OAAO,IAAI,CAACC,cAAc,EAAE;MACxDG,cAAc,CAAEU,OAAO,IAAKA,OAAO,GAAG,CAAC,CAAC;IAC1C;EACF,CAAC,EAAET,OAAO,CAAC;EAEb,OAAOI,QAAQ;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}